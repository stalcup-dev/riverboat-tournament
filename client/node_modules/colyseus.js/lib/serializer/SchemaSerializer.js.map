{"version":3,"file":"SchemaSerializer.js","sourceRoot":"","sources":["../../src/serializer/SchemaSerializer.ts"],"names":[],"mappings":";;;AAcA,8CASC;AAtBD,6CAAmG;AAKnG,EAAE;AACF,qHAAqH;AACrH,GAAG;AACH,QAAQ;AACR,2GAA2G;AAC3G,4EAA4E;AAC5E,MAAM;AACN,EAAE;AACF,SAAgB,iBAAiB,CAAI,IAAa;IAC9C,IAAI,CAAC;QACD,mBAAmB;QACnB,aAAa;QACb,OAAO,IAAA,iCAAwB,EAAK,IAAI,CAAC,YAAY,CAAoC,CAAC,OAAO,CAAC,CAAC;IACvG,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACT,iBAAiB;QACjB,OAAO,SAAS,CAAC;IACrB,CAAC;AACL,CAAC;AAED,MAAa,gBAAgB;IAIzB,QAAQ,CAAC,YAAoB,EAAE,EAAa;QACxC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;IAC1C,CAAC;IAED,QAAQ;QACJ,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,OAAe,EAAE,EAAa;QAChC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;IAC5C,CAAC;IAED,QAAQ;QACJ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;IAClC,CAAC;IAED,SAAS,CAAC,KAAa,EAAE,EAAa;QAClC,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,EAAE;YACF,mEAAmE;YACnE,EAAE;YACF,mBAAU,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ;YAEtC,IAAI,CAAC,OAAO,GAAG,IAAI,gBAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE3C,CAAC;aAAM,CAAC;YACJ,yCAAyC;YACzC,IAAI,CAAC,OAAO,GAAG,mBAAU,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YAC5C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;QACpC,CAAC;IACL,CAAC;CACJ;AAnCD,4CAmCC","sourcesContent":["import { Serializer } from \"./Serializer\";\nimport { Schema, Decoder, Reflection, Iterator, getDecoderStateCallbacks } from \"@colyseus/schema\";\nimport type { Room } from \"../Room\";\n\nexport type SchemaConstructor<T = Schema> = new (...args: any[]) => T;\n\n//\n// TODO: use a schema interface, which even having duplicate definitions, it could be used to get the callback proxy.\n// \n// ```ts\n//     export type SchemaCallbackProxy<RoomState> = (<T extends ISchema>(instance: T) => CallbackProxy<T>);\n//     export function getStateCallbacks<T extends ISchema>(room: Room<T>) {\n// ```\n//\nexport function getStateCallbacks<T>(room: Room<T>) {\n    try {\n        // SchemaSerializer\n        // @ts-ignore\n        return getDecoderStateCallbacks<T>((room['serializer'] as unknown as SchemaSerializer<T>).decoder);\n    } catch (e) {\n        // NoneSerializer\n        return undefined;\n    }\n}\n\nexport class SchemaSerializer<T extends Schema = any> implements Serializer<T> {\n    state: T;\n    decoder: Decoder<T>;\n\n    setState(encodedState: Buffer, it?: Iterator) {\n        this.decoder.decode(encodedState, it);\n    }\n\n    getState() {\n        return this.state;\n    }\n\n    patch(patches: Buffer, it?: Iterator) {\n        return this.decoder.decode(patches, it);\n    }\n\n    teardown() {\n        this.decoder.root.clearRefs();\n    }\n\n    handshake(bytes: Buffer, it?: Iterator) {\n        if (this.state) {\n            //\n            // TODO: validate definitions against concreate this.state instance\n            //\n            Reflection.decode(bytes, it); // no-op\n\n            this.decoder = new Decoder(this.state);\n\n        } else {\n            // initialize reflected state from server\n            this.decoder = Reflection.decode(bytes, it);\n            this.state = this.decoder.state;\n        }\n    }\n}\n"]}