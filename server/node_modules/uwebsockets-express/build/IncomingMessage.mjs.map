{
  "version": 3,
  "sources": ["../src/IncomingMessage.ts"],
  "sourcesContent": ["import uWS from \"uWebSockets.js\";\nimport http from \"http\";\nimport querystring from \"querystring\";\nimport EventEmitter from \"events\";\nimport { URL } from \"url\";\nimport { request } from \"express\";\nimport { Socket } from \"./Socket.js\";\nimport { Application } from \"./Application.js\";\n\nexport class IncomingMessage extends EventEmitter implements http.IncomingMessage {\n  public url: string;\n  public originalUrl: string; // used by express router\n  public method: string;\n\n  // public query: querystring.ParsedUrlQuery;\n\n  // private _url: string;\n  // private _path: string;\n  private _baseUrl: string = \"\";\n  private _rawquery: string;\n  private _query: querystring.ParsedUrlQuery;\n  private _headers: http.IncomingHttpHeaders = {};\n  private _params: {[name: string]: string};\n  private _bodydata: any;\n  private _rawbody: any;\n  private _remoteAddress: ArrayBuffer;\n  private _readableState = { pipes: [] };\n  private _readBodyMaxTime = 500;\n\n  public aborted: boolean;\n\n  // @ts-ignore\n  public socket = new Socket(false, true);\n\n  #_originalUrlParsed: URL;\n  private parameterNames: string[] = [];\n\n  constructor(\n    private req: uWS.HttpRequest,\n    private res: uWS.HttpResponse,\n    private app: Application,\n    initialData?: {\n      headers?: http.IncomingHttpHeaders;\n      url?: string;\n      method?: string;\n      body?: any;\n      query?: string;\n      remoteAddress?: ArrayBuffer;\n    }\n  ) {\n    super();\n\n    this._headers = initialData?.headers || {};\n\n    if (!initialData?.headers) {\n      this.req.forEach((key, value) => this._headers[key] = value);\n    }\n\n    this.url = initialData?.url || this.req.getUrl();\n    this.method = (initialData?.method || this.req.getMethod()).toUpperCase();\n\n    this._rawquery = initialData?.query || this.req.getQuery();\n    this._remoteAddress = initialData?.remoteAddress || this.res.getRemoteAddressAsText();\n\n    if (this._headers['referer']) {\n      this._headers['referrer'] = this._headers['referer'];\n    }\n\n    if (this._rawquery) {\n      this.url += `?${this._rawquery}`;\n    }\n\n    this.#_originalUrlParsed = new URL(`http://server${this.url}`);\n\n    if (this.app.opts?.readBodyMaxTime) {\n      this._readBodyMaxTime = this.app.opts.readBodyMaxTime;\n    }\n  }\n\n  get ip () {\n    return Buffer.from(this._remoteAddress).toString();\n  }\n\n  set body (_body: any) {\n    this._bodydata = _body;\n  }\n\n  get body () {\n    return this._bodydata || this._rawbody?.toString();\n  }\n\n  get headers (): http.IncomingHttpHeaders {\n    return this._headers;\n  }\n\n  set params (value) {\n    this._params = value;\n  }\n\n  get params(): { [name: string]: string } {\n    if (!this._params) {\n      this._params = {};\n      for (let i = 0; i < this.parameterNames.length; i++) {\n        const paramName = this.parameterNames[i];\n        this._params[paramName] = this.req.getParameter(i);\n      }\n    }\n\n    return this._params;\n  }\n\n  get query (): querystring.ParsedUrlQuery {\n    if(!this._query) this._query = querystring.parse(this._rawquery);\n    return this._query;\n  }\n\n  get baseUrl() {\n    return this._baseUrl;\n  }\n\n  set baseUrl(baseUrl) {\n    this._baseUrl = baseUrl;\n  }\n\n  get path(): string {\n    const path = this.#_originalUrlParsed.pathname.replace(this._baseUrl, \"\");\n    return (!path.startsWith(\"/\"))\n      ? `/${path}`\n      : path;\n  }\n\n  get(name: string) {\n    return this.header(name);\n  }\n\n  header(name: string) {\n    name = name.toLowerCase();\n    return this._headers[name] || undefined;\n  }\n\n  accepts(...args: any[]): string | false {\n    return request.accepts.apply(this, arguments);\n  }\n\n  resume() { return this; }\n\n  on(event: string | symbol, listener: (...args: any[]) => void) {\n    if (event === 'data' && this._rawbody !== undefined) {\n      /**\n       * req.body is synchronously before any middleware runs.\n       * here we're mimicking to trigger 'data' + 'end' + 'close' right at the moment the event is registered.\n       */\n      setImmediate(() => {\n        listener(this._rawbody);\n        this.emit('end');\n        this.emit('close');\n      });\n    } else {\n      super.on(event, listener);\n    }\n    return this;\n  }\n\n  protected _readBody () {\n    return new Promise<boolean>((resolve, reject) => {\n      let body: Buffer;\n\n      //\n      // ensure request is not halted when an invalid content-length is sent by the client\n      // https://github.com/endel/uWebSockets-express/issues/9\n      //\n      const rejectionTimeout = setTimeout(() => {\n        if (body) {\n          this._rawbody = body;\n          this.headers['content-length'] = String(body.length);\n        }\n        reject();\n      }, this._readBodyMaxTime);\n\n      this.res.onData((arrayBuffer, isLast) => {\n        const chunk = Buffer.from(arrayBuffer);\n        body = (body && body.length !== 0) ? Buffer.concat([body, chunk]) : Buffer.concat([chunk]);\n\n        if (isLast) {\n          clearTimeout(rejectionTimeout);\n          this._rawbody = body;\n          resolve(body.length > 0);\n        }\n      });\n    })\n  }\n\n}\n"],
  "mappings": "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",
  "names": []
}
